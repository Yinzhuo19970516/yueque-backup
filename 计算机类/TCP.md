# TCP
## TCP 握手没成功怎么办？

### TCP 三次握手

客户端 服务端  
 发送 SYN Seq 客户端随机数 X--->  
 <---发送 SYN Seq 服务端随机数 Y ACK =X+1  
 发送 ACK = Y+1 Seq 客户端随机数 Z-->

### 第一次握手丢失，会发生什么？

客户端发送 syn 之后，进入等待状态，如果迟迟未收到第二次握手，会触发超时重传机制。  
超时后，客户端就会重新发送 SYN 报文。  
重发次数也是有限。重传等待的时间呈指数级别增长。  
超过重传次数，断开 TCP 连接。

### 第二次握手丢失，会发生什么？

服务端发送完毕， 进入 SYN_RCVD 状态  
如果客户端迟迟没有收到第二次握手，客户端就会认为自己报文丢失了，触发超时重新传机制  
如果第二次握手丢失了，服务端收不到第三次握手，于是服务端触发超时重传机制  
因此，当第二次握手丢失了，客户端和服务端都会重传：

- 客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 tcp_syn_retries 内核参数决定。
- 服务端会重传 SYN-AKC 报文，也就是第二次握手，最大重传次数由 tcp_synack_retries 内核参数决定。

### 第三次握手丢失，会发生什么？

因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。  
**ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文。**

### TCP 四次挥手

客户端 服务端  
 发送 FIN 请求关闭连接-->  
 <--发送 ACK 和 FIN 收到关闭请求  
 <--发送关闭请求 FIN  
 发送 ACK，确认收到关闭请求-->  
 服务端关闭  
 客户端 2MSL 之后关闭

### 第一次挥手丢失了，会发生什么？

客户端接受不到 ACK，触发超时重传机制，继续发送 FIN 报文

### 第二次挥手丢失了，会发生什么？

所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。

### 第三次挥手丢失了，会发生什么？

如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 tcp_orphan_retries 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。

### 第四次挥手丢失了，会发生什么？

如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 tcp_orphan_retries 参数控制。

<br>
  
> 语雀地址 https://www.yuque.com/yuqueyonghuyv23kd/zxkn1f/bngzah