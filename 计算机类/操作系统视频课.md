# 操作系统视频课
**时间分配**  
第二次打卡看完前六章 共 12 章，14 天看完一半就算成功  
4.24 1.1-1.8 结束  
4.25 2.1-2.2  
4.26 3.1-3.2  
4.27 3.3-3.4  
4.28 4.1-4.2  
4.29 4.3-4.5  
4.30 5.1-5.3  
5.1 5.4-5.5  
5.2 6.1-6.3  
5.3 6.4-6.7  
5.4 6.8-6.10  
5.8 7.1-7.7  
5.9 7.8-7.14  
5.10 8.1-8.2  
5.11 8.2-8.3  
5.12 8.5-8.6  
5.13 9.1-9.4  
5.14 9.5 -9.8  
5.15 10.1 -10.4  
5.16 10.5  
5.17 10.6-10.9  
5.18 10.10-10.11  
4.24  
#共读打卡  
 1 / 14  
【星球编号】：44  
【打卡内容】：视频课《清华 操作系统原理》[https://www.bilibili.com/video/BV1uW411f72n?p=12&spm_id_from=pageDriver](https://www.bilibili.com/video/BV1uW411f72n?p=12&spm_id_from=pageDriver)  
【读书笔记】：  
操作系统主要模块：ＣＰＵ的调度，物理内存管理，虚拟内存管理，文件系统管理，中断处理与设备驱动  
操作系统主要特征：并发（可同时处理多个运行程序，需要 os 调度和管理），共享（如何共享资源），虚拟（硬件虚拟化），异步  
【阅读感悟】：  
先说说为什么学习这门课，3 月面试被问，线程和线程之间如何通信，进程之间如何调度。我瞬间蒙圈，和同学吐槽了这件事，同学义正言辞的指出了线程和线程之间 5 种通信方式，反问我大学操作系统怎么学的，这怎么不知道呢?我羞愧难当，他发了一门清华大学的操作系统课程给我，说他是通过这个课程自学的。我拿到视频链接当下就收藏了，可是一个月过去了，依然只看了两节，这样很不好。正好有这个打卡活动，于是想借助团队的力量，来反推自己前进，在这次打卡活动中争取看完一半。这期视频打卡内容就以视频笔记和个人感悟为主了。  
#共读打卡  
 2 / 14  
【星球编号】：44  
【打卡内容】：视频课《清华 操作系统原理》[第二章](https://www.bilibili.com/video/BV1uW411f72n?p=12&spm_id_from=pageDriver)  
【读书笔记】：  
**操作系统与设备程序交互方式:**  
面向外设通过中断 I/0 处理  
面向程序通过系统调用和异常处理  
**中断 **  
概念：中断是指 CPU 在执行当前程序时系统出现了某种状况，使得 CPU 必须停止当前程序，而去执行另一段程序来处理的出现的紧急事务，处理结束后 CPU 再返回到原先暂停的程序继续执行，这个过程就称为中断。  
**处理过程**  
硬件：标记中断号  
软件：保存当前被打断进进程的执行处理状态  
中断服务程序处理  
清除中断标记  
恢复之前保存的处理状态  
**异常：**  
概念：程序意想不到的行为  
**处理过程**  
保存现场  
异常处理（杀死程序，或者重新执行指令）  
恢复现场（重新执行指令）  
**系统调用：**  
概念：应用程序主动向 os 发出请求，申请系统资源（设备管理，文件管理，进程管理，进程通信，内存管理）  
处理过程  
用户态到内核态的转化（内核态可以调用很多特殊指令，完全控制整个操作系统，开销更大）  
控制权从应用程序到操作系统  
#共读打卡  
3/14  
【星球编号】：44  
【打卡内容】：视频课《清华 操作系统原理》[3.1-3.2](https://www.bilibili.com/video/BV1uW411f72n?p=12&spm_id_from=pageDriver)  
【读书笔记】：  
**复习计算机原理知识**  
计算机基本硬件结构：CPU(中央处理器) 存储器 设备 总线  
内存层次结构（CPU 访问内存和磁盘的层次顺序）寄存器 cache 物理内存 硬盘  
速度越来越慢，空间越来越大  
**操作系统中管理内存的不同方法：**  
程序重定位 分段 分页 虚拟内存 按需分页虚拟内存  
**地址空间&地址生成**  
物理地址空间：硬件支持的地址空间  
逻辑地址空间：一个运行的程序拥有的内存范围  
逻辑地址生成过程：编译 汇编 链接 载入  
逻辑地址和物理地址有映射关系，映射关系存储在内存中  
操作系统做的事情在于建立映射表  
【阅读感受】：  
前三章感觉还在丰富操作系统的基本概念，都是一些宏观的东西，还没有到各个部分的具体设计，还比较枯燥，难理解，就像课程最开始所说，操作系统这门课程，是程序设计，数据结构，计算机原理多个课程的综合，总会需要复习一些其他课程的内容。  
#共读打卡  
5/14  
【星球编号】：44  
【打卡内容】：视频课《清华 操作系统原理》[4.1-4.2](https://www.bilibili.com/video/BV1uW411f72n?p=12&spm_id_from=pageDriver)  
【读书笔记】：  
**为什么需要非连续内存分配**  
连续内存分配方式或多或少都会有内外碎片问题  
**两种硬件方案**  
**分段**  
逻辑地址空间分散到多个物理地址空间，连续的逻辑地址被分成了不连续的物理地址空间  
**分段寻址方案**  
段号 + 段内偏移地址  
通过段表，去查找段号对应的物理地址，段表由操作系统建立  
通过偏移地址，去找具体所在段  
**分页**  
分页是大部分 os 主流方案  
划分物理内存只固定大小的帧，划分逻辑地址空间至大小相同的页  
**分页寻址方案**  
页号 + 页内偏移  
通过页表，去查找对应的帧号  
通过帧号+偏移量，去查找物理地址  
#共读打卡  
6/14  
【星球编号】：44  
【打卡内容】：视频课《清华 操作系统原理》[4.3-4.5](https://www.bilibili.com/video/BV1uW411f72n?p=12&spm_id_from=pageDriver)  
【读书笔记】：  
**分页机制性能问题**  
访问一个内存单元需要 2 次内存访问  
一个获取页表项  
一个访问数据  
页表可能会很大  
**时间开销减小**  
缓存近期访问的页帧转换表项 TLB  
快表 TLB 存放在 CPU 中，具备快速访问性能，每次先检查 TLB 是否命中  
**空间开销减小**  
多级页表方案  
一级目录变成多级目录，多了一次查表，使得页表变小，非关键信息可以放二级页表，类似 DNS 查询过程，树型结构。  
**大地址空间问题，出现深层级页表**  
对于 32 位机器采用多级页表勉强足够存储页表项，但是对于 64 位机器，那总地址空间大小为 2^64，如果每个页面大小是 4K，那么就需要 2^64/4K=2^64/2^12=2^52 数目的页面，这个如果只用一级页表，在内存中用指针存储的话，按每个指针 4byte，那就一共要 4\*2^52=2^56byte，远超过目前的物理内存量级，所以在内存里存不下，即使采用 5 级页表也难以存储下这么多地址。  
反向页表  
正常页表结构，一个进程就会有一个页表，反向页表表存储的是一个通用表，映射是物理地址，值是逻辑地址。至于怎么转换，老师没讲清楚，我也没有理解  
#共读打卡  
7/14  
【星球编号】：44  
【打卡内容】：视频课《清华 操作系统原理》[5.1-5.3](https://www.bilibili.com/video/BV1uW411f72n?p=12&spm_id_from=pageDriver)  
【读书笔记】：  
**虚拟内存的起因**  
经常出现内存不够用的情况，程序规模增长大于存储器容量的增长  
理想的存储器：更大，更快，更便宜，非易失性存储  
不常用的放在硬盘上，常用的放在内存上  
计算机系统，多道程序运行的环境中，内存不够用的解决方案  
**覆盖技术**  
目标：  
出现在 80 年代，比较小的内存运行比较大的程序  
思路：  
程序按功能划分模块，常用模块，不常用模块，常用模块在内存中，不常用模块在外存中，需要时在放入内存执行。无调用关系的模块，分时装入内存可以直接覆盖，按时间顺序执行。  
缺点：  
程序设计太复杂  
**交换技术**  
目标：  
让正在运行的程序或者需要运行的程序获取更多的内存资源  
思路：  
将暂时不能运行的程序送到外存，从而获得更多的内存空间  
换入换出  
难点：  
交换时机不好确定  
交换空间的大小不好确定  
#共读打卡  
8/14  
【星球编号】：44  
【打卡内容】：视频课《清华 操作系统原理》[5.4-5.5](https://www.bilibili.com/video/BV1uW411f72n?p=12&spm_id_from=pageDriver)  
【读书笔记】：  
**虚存技术**  
虚拟内存管理技术  
**目标**：  
结合覆盖技术和交换技术的优点  
**程序的局部性原理**：  
程序在执行的一个较短时间，所执行的指令和指令操作数地址分别局限与一个区域  
程序局部性原理表面，理论上，虚拟内存技术是可行的  
**基本概念**：  
可以在页式或者段式内存管理的基础上实现  
只需将当前需要执行的部分分页或者分段放入内存  
出现缺页或者缺段是，再把页或者段调入内存  
也可以把不需要的页和段保存在外存中  
**基本特征**：  
大的用户空间  
部分交换  
不连续：物理地址分配不连续，虚拟地址空间使用不连续  
**请求调页&页面置换功能**  
**页表表项**  
**逻辑页号+访问位 + 保护位 +修改位 + 驻留位 +物理页帧号**  
访问位：是否被访问过，后续页面置换算法会用到  
保护位：访问权限  
修改位：是否被修改过  
驻留位：所在位置，内存或者外存，如果访问这个，说明出现缺页中断  
#共读打卡  
9/14  
【星球编号】：44  
【打卡内容】：视频课《清华 操作系统原理》[6.1-6.4](https://www.bilibili.com/video/BV1uW411f72n?p=12&spm_id_from=pageDriver)  
【读书笔记】：  
**页面置换算法**  
**功能**：  
当出现缺页中断，需要调入新的页面，内存已经满了，应该选择哪个页面被置换  
**目标**：  
尽可能减少页面换进换出的次数（即缺页中断次数）  
**最优页面置换算法**  
**思路**：  
选择下一次访问还需要等待时间最长的页面置换  
**实际**：  
获得下一次访问的时机，实际操作太难，太过理想化，但是可以做为其他算法的对比标准  
**先进先出算法 FIFO**  
**思路**：  
选择在内存中驻留时间最长的页面并置换  
维护一个链表，新加页面增加到链表尾部，老得页面在头部。  
**实际：**  
页面很多，性能较差，很少单独使用  
**最近最久未使用页面算法 LRU**  
**思路**：  
最优页面置换算法的一个近似，如果过去很长时间没有被访问，则被替换  
**实际**：  
需要记录各个页面使用时间的先后顺序  
开销比较大，可能的实现方案  
维护一个栈，当访问某页时，将此页号压入栈顶，然后考察栈内是否有于此相同的页号，若有则抽出，当需要淘汰一个页面时，总是选择栈低元素  
**时钟页面置换算法 Clock**  
思路：  
LRU 的近似，FIFO 的改进  
需要用到页表项的访问位，当页面被装入内存，该位初始化为 0，如果这个页面被访问，该位置置 1（硬件完成）  
操作系统定期清 0（探测过就清 0），把各个页面组织成环形结构，把指针指向最老的页面（为 0 的页面）  
#共读打卡  
10/14  
【星球编号】：44  
【打卡内容】：视频课《清华 操作系统原理》[6.5-6.7](https://www.bilibili.com/video/BV1uW411f72n?p=12&spm_id_from=pageDriver)  
【读书笔记】：  
**二次机会法**  
时钟算法，只要被读或者被写都认为被访问，开销很大  
区分读和写操作，同时使用修改位和访问位来区分，如果修改位和访问位都是 0，则必须替换，如果修改位是 1，访问位都是 1，那么修改位不变，访问位置为 1。  
总结就是，只读的页面优先替换  
**最不常用算法 LFU**  
**思路**：  
缺页中断时，选择访问次数最少的那个页面，并淘汰  
**实现：**  
对每个页面增加一个访问计数器，当访问时，计数器加一  
LRU 关注时间，LFU 关心次数  
当出现某个程序某个时间段多次使用，之后再不使用，此时 LFU 不靠谱，所以需要定时计数器清除  
**Belay 现象**  
当使用 FIFO 算法时，有时会出现分配的物理页面数增加，缺页率反而提高的现象  
程序访问是动态的，如果暴力的替换，先进先出，不符合程序动态的原则  
LRU 不会有这种现象  
11/14  
【星球编号】：44  
【打卡内容】：视频课《清华 操作系统原理》[6.8-6.10](https://www.bilibili.com/video/BV1uW411f72n?p=12&spm_id_from=pageDriver)  
【读书笔记】：  
**局部页面置换算法的问题**  
操作系统会同时运行多个程序，分配的物理页帧也是动态的  
**工作集模型**  
工作集：一个进程当前使用的逻辑页面集合  
常驻集： 当前时刻，进程实际驻留在内存中的页面集合  
**两个全局置换算法： **  
基于缺页率的页面置换算法  
策略：常驻集大小可变，缺页率高的进程，多分配物理页面  
缺页率 = 缺页次数/内存访问次数  
我理解就是滑动窗口拉长，缺页率高的时候，增加工作集，缺页率低的时候，减少工作集  
**抖动问题**  
如果分配的常驻集远远小于工作集，会频繁出现缺页中断，需要频繁在内存外存之间替换页面，从而使得进程运行很慢，我们把这种叫做抖动问题  
12/14  
【星球编号】：44  
【打卡内容】：视频课《清华 操作系统原理》[7.1-7.7](https://www.bilibili.com/video/BV1uW411f72n?p=12&spm_id_from=pageDriver)  
【读书笔记】：  
**第七章：进程管理**  
**进程的描述**  
**定义**  
一个具有一定独立功能的程序在以恶搞数据集合上一次动态执行过程  
**进程的组成**  
代码，处理的数据，堆栈信息，系统资源等，正在运行的程序的所有信息  
**进程的特点**  
动态性：可动态的创建结束  
并发性：可并发（一段时间） 区别并行的概念（同一时刻）  
独立性：不同进程的工作互不影响  
制约性：因访问共享数据或者进程间同步会有互斥制约  
**进程控制块**  
描述进程的数据结构：进程控制块 PCB process control block  
主要包括三部分信息  
进程标识信息： 如本进程的产生标识，产生者标识，用户标识  
处理机状态信息保存区：  
用户可见的寄存器  
控制和状态寄存器  
堆栈信息  
进程控制信息  
调度和状态信息  
进程间的通信信息  
存储管理信息  
进程所用资源  
PCB 的组织方式：链表和索引表  
**进程的状态**  
**进程声明周期管理**  
进程创建  
系统初始化时  
用户请求创建一个新程序时  
正在运行的进程执行了创建进程的系统调用  
进程运行  
内核选择一个就绪的进程，让它占用处理机并执行  
进程等待（阻塞）  
异步操作依赖结果  
进程只能自己阻塞自己，因为只有进程自己知道何时需要等待  
进程唤醒  
拿到异步数据  
进程结束  
正常退出  
错误退出  
致命错误  
被其他进程关闭  
进程三个基本状态  
运行状态 running  
就绪状态 ready  
等待状态 blocked  
其他基本状态 创建状态 new 结束状态 exit  
进程挂起  
进程没有占用内存空间，处于挂起状态的进程映像在磁盘上  
挂起就是把一个进程从内存转到外存  
激活/解挂 就是把进程从外存转到内存  
状态队列：  
就绪队列 阻塞队列 不同到状态用不同的队列维护  
13/14  
【星球编号】：44  
【打卡内容】：视频课《清华 操作系统原理》[7.7-7.10](https://www.bilibili.com/video/BV1uW411f72n?p=12&spm_id_from=pageDriver)  
【读书笔记】：  
**线程管理**  
**为什么使用线程**  
有并发执行的场景  
且需要共享共同的地址空间，所以进程不合适了，提出了新的概念  
**什么是线程**  
进程当中的一条执行流程  
Thread control block TCB  
线程 = 进程 - 共享资源  
一个进程可同时存在多条线程，可并发执行，共享地址空间和文件资源  
一个线程崩溃，会导致其他线程全部 gg  
**线程和进程的比较**  
进程是资源分配单位，线程是 CPU 调度单位  
进程拥有一个完整的资源平台  
线程同样具有就绪，阻塞，执行三个状态  
线程能减少并发执行的空间和时间开销  
**进程间通信**  
上下文切换：停止当前运行进程并且调度其他进程  
进程上下文：寄存器，CPU 状态  
进程切换上下文开销很大，尽量避免

<br>
  
> 语雀地址 https://www.yuque.com/yuqueyonghuyv23kd/zxkn1f/fxaq3a